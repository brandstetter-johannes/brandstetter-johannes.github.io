<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Publications | Johannes Brandstetter</title><link>https://brandstetter-johannes.github.io/category/publications/</link><atom:link href="https://brandstetter-johannes.github.io/category/publications/index.xml" rel="self" type="application/rss+xml"/><description>Publications</description><generator>Wowchemy (https://wowchemy.com)</generator><language>en-us</language><lastBuildDate>Wed, 19 Jul 2023 00:00:00 +0000</lastBuildDate><image><url>https://brandstetter-johannes.github.io/images/icon_hu3751bf80caad288f7f32134a8ecae786_4078_512x512_fill_lanczos_center_3.png</url><title>Publications</title><link>https://brandstetter-johannes.github.io/category/publications/</link></image><item><title>PDE-Refiner - Achieving Accurate Long Rollouts with Neural PDE Solvers</title><link>https://brandstetter-johannes.github.io/post/pderefiner/</link><pubDate>Wed, 19 Jul 2023 00:00:00 +0000</pubDate><guid>https://brandstetter-johannes.github.io/post/pderefiner/</guid><description>&lt;p>Check out our project page: &lt;a href="https://phlippe.github.io/PDERefiner/">&lt;a href="https://phlippe.github.io/PDERefiner/" target="_blank" rel="noopener">https://phlippe.github.io/PDERefiner/&lt;/a>&lt;/a>!&lt;/p>
&lt;p>&lt;strong>Abstract&lt;/strong>: Time-dependent partial differential equations (PDEs) are ubiquitous in science and engineering. Recently, mostly due to the high computational cost of traditional solution techniques, deep neural network based surrogates have gained increased interest. The practical utility of such neural PDE solvers relies on their ability to provide accurate, stable predictions over long time horizons, which is a notoriously hard problem. In this work, we present a large-scale analysis of common temporal rollout strategies, identifying the neglect of non-dominant spatial frequency information, often associated with high frequencies in PDE solutions, as the primary pitfall limiting stable, accurate rollout performance. Based on these insights, we draw inspiration from recent advances in diffusion models to introduce PDE-Refiner; a novel model class that enables more accurate modeling of all frequency components via a multi-step refinement process. We validate PDE-Refiner on challenging benchmarks of complex fluid dynamics, demonstrating stable and accurate rollouts that consistently outperform state-of-the-art models, including neural, numerical, and hybrid neural-numerical architectures. Finally, PDE-Refiner&amp;rsquo;s connection to diffusion models enables an accurate and efficient assessment of the model&amp;rsquo;s predictive uncertainty, allowing us to estimate when the surrogate becomes inaccurate.&lt;/p></description></item><item><title>BISCUIT - Causal Representation Learning from Binary Interactions</title><link>https://brandstetter-johannes.github.io/post/biscuit/</link><pubDate>Wed, 21 Jun 2023 00:00:00 +0000</pubDate><guid>https://brandstetter-johannes.github.io/post/biscuit/</guid><description>&lt;p>Check out our project page: &lt;a href="https://phlippe.github.io/BISCUIT/">&lt;a href="https://phlippe.github.io/BISCUIT/" target="_blank" rel="noopener">https://phlippe.github.io/BISCUIT/&lt;/a>&lt;/a>!&lt;/p>
&lt;p>&lt;strong>Abstract&lt;/strong>: Identifying the causal variables of an environment and how to intervene on them is of core value in applications such as robotics and embodied AI. While an agent can commonly interact with the environment and may implicitly perturb the behavior of some of these causal variables, often the targets it affects remain unknown. In this paper, we show that causal variables can still be identified for many common setups, e.g., additive Gaussian noise models, if the agent&amp;rsquo;s interactions with a causal variable can be described by an unknown binary variable. This happens when each causal variable has two different mechanisms, e.g., an observational and an interventional one. Using this identifiability result, we propose BISCUIT, a method for simultaneously learning causal variables and their corresponding binary interaction variables. On three robotic-inspired datasets, BISCUIT accurately identifies causal variables and can even be scaled to complex, realistic environments for embodied AI.&lt;/p></description></item><item><title>Normalizing Flows on categorical data</title><link>https://brandstetter-johannes.github.io/post/categorical-nf/</link><pubDate>Sat, 23 Jan 2021 00:00:00 +0000</pubDate><guid>https://brandstetter-johannes.github.io/post/categorical-nf/</guid><description>&lt;p>Ever since Generative Adversarial Networks have shown to generate realistic fake images, or GPT3 creating new, convincing text snippets, generative modeling has been a very popular research area, but also for future applications. One family of generative models, that allows both efficient sampling (i.e. generating new data) and exact density evaluation (i.e. determining the likelihood of a sample) is Normalizing Flows. Normalizing Flows model distributions by applying a sequence of invertible transformations mapping the input distribution to a known base distribution such as a factorized Gaussian. Successful applications include image and audio generation. However, a lot of real world data is categorical nature where variables represent a discrete value in a finite set. For instance, language is based on categorical data as words or characters represent different categories. Another popular example is molecule graphs where not only the nodes can be one out of many atom types, but also the edges (i.e. bonds between atoms) can have different categories. In this blog post, we will discuss what challenges there are for Normalizing Flows to be applied to categorical data, how Categorical Normalizing Flow offer a solution to those, and how we can extend this framework to a permutation-invariant graph generation model.&lt;/p>
&lt;figure>
&lt;img src="intro_categorical_data.svg" width="70%">
&lt;figcaption>&lt;b>Figure 1&lt;/b>: Common applications that involve categorical data are language modeling (left) and use cases in biology and chemistry like molecule generation (right).&lt;/figcaption>
&lt;/figure>
&lt;h2 id="normalizing-flows-on-categorical-data">Normalizing Flows on categorical data&lt;/h2>
&lt;p>Normalizing Flows rely on the rule of change of variables which is naturally defined on continuous space. Attempts to apply Normalizing Flows directly on discrete data by discretizing their transformations suffer from optimization difficulties as biased gradient estimator need to be used. Besides, Discrete Normalizing Flows are not as flexible as their continuous counterparts. In the context of image modeling, a popular technique is to move the images into continuous space by &lt;em>dequantizing&lt;/em> the discrete data, effectively adding a small amount of noise to transform a discrete point to a volume in continuous space. However, this works for images because their discrete values represent integers where 0 is closer to 1 than 128, and so on. In terms of categorical data, we cannot take such assumptions (for instance, is the letter &lt;em>a&lt;/em> closer to &lt;em>m&lt;/em> or &lt;em>r&lt;/em>?). Instead, we would need a learnable encoding function from categorical to continuous space, which supports higher dimensions to represent more complex relations between categories. At the same time, no information should be lost when moving into continuous space, as we want to use all the benefits of Normalizing Flows.&lt;/p>
&lt;p>Categorical Normalizing Flows offer a solution to this problem by using variational inference, but with a factorized decoder. In a VAE, an encoder maps the whole input to a smaller latent space, and a consecutive decoder tries to reconstruct the original input. In contrast, in Categorical Normalizing Flows, the encoder maps each categorical variable to a corresponding continuous variable in latent space, and the decoder is independently applied on those latent variables. A standard Normalizing Flow can then be applied on those continuous variables to map to a prior distribution like a Gaussian. This way, only the flow can model interactions between categorical variables, and the encoder-decoder framework is limited to providing suitable continuous representations to the flow. An overview of this architecture is given in the figure below, and details on this approach can be found in our &lt;a href="https://openreview.net/pdf?id=-GLNZeVDuik" target="_blank" rel="noopener">paper&lt;/a>.&lt;/p>
&lt;figure>
&lt;img src="flow_structure.svg" width="90%">
&lt;figcaption>&lt;b>Figure 2&lt;/b>: An encoder $q$ maps the categorical input $x$ (here text) to continuous latent variables $z$. Each word is thereby represented by a separate two-dimensional latent variable, based on which the decoder reconstructs the categorical data. The Normalizing Flow learns to map the continuous representations to a prior distribution, such as a Gaussian.&lt;/figcaption>
&lt;/figure>
&lt;p>In experiments on sets and language modeling, Categorical Normalizing Flows are able to match the performance of non-latent based autoregressive baselines while considerably outperforming VAE-based approaches with joint decoders. This shows the effectivity of using a factorized decoder, and focusing the modeling complexity into the flow.&lt;/p>
&lt;h2 id="graphcnf-permutation-invariant-graph-modeling">GraphCNF: permutation-invariant graph modeling&lt;/h2>
&lt;p>Besides language, graph generation is another domain where categorical data plays an essential role. To make it more specific, we put our focus here on molecule generation, but note that the approach outlined below can also be applied to other graph generation tasks with categorical attributes, such as graph coloring.&lt;/p>
&lt;p>Modeling and generating graphs is crucial in biology and chemistry for applications such as drug discovery, where molecule generation has emerged as a common benchmark. In a molecule graph, the nodes are atoms and he edges represent bonds between atoms, both represented by categorical features. The figure below shows a small molecule and its corresponding graph representation as an example.&lt;/p>
&lt;figure>
&lt;img src="molecule_graph.svg" width="70%">
&lt;figcaption>&lt;b>Figure 3&lt;/b>: The molecule on the left can be represented as graph by considering its atoms as nodes, and bonds as edges. The different colors of nodes and edges in the graph on the right visualize different categories. Note that the nodes without text in the molecule on the left are carbon atoms.&lt;/figcaption>
&lt;/figure>
&lt;p>Given a dataset of existing molecules, the goal is to learn a distribution of valid molecules as not all possible combinations of atoms and bonds are valid. We train the model via maximum likelihood on the existing data. Thereby, we need to model three parts of the graph: the node attributes (i.e. atom types), the edge attributes (i.e. bond category), and the adjacency matrix (i.e. whether two atoms have a bond at all or not). Furthermore, another challenge is that the nodes are unordered, meaning they have to be considered as a set and not as a list. Hence, any permutation of the nodes has to be assigned the exact same likelihood.&lt;/p>
&lt;p>Using Categorical Normalizing Flows, we can implement this in a three-step approach as visualized in Figure 4, and call the approach GraphCNF. First, we map the node categories into continuous space using the approach of Categorical Normalizing Flows discussed above. On those latent variables, we apply a small sequence of coupling layers conditioned on the rest of the graph structure. In the second step, we map the edge attributes into continuous space, and apply another set of coupling layers. Finally, in the last step, we add the &lt;em>virtual edges&lt;/em>, i.e. the edges that are not present in our graph. We add those as another edge category using Categorical Normalizing Flows, and apply a final set of coupling layers. Note that as those are applied on a fully connected graph now, this is the most expensive step of GraphCNF.&lt;/p>
&lt;figure>
&lt;img src="graphcnf.svg" width="100%">
&lt;figcaption>&lt;b>Figure 4&lt;/b>: Visualization of GraphCNF for an example graph of five nodes. We add the node and edge attributes, as well as the virtual edges stepwise to the latent space while leveraging the graph structure in the coupling layers. The last step considers a fully connected graph with features per edge.&lt;/figcaption>
&lt;/figure>
&lt;p>To ensure permutation invariance, all coupling layers use channel-wise masking, and all neural networks in the model are permutation equivariant graph neural networks (i.e. any permutation give the same output, just permuted). When applying this model to molecule generation and randomly sample 10k molecules from it, we see that more than 83% are actual valid molecules. Furthermore, most of them are unique and novel compared to the training dataset, showing that GraphCNF actually generalizes and does not just remember the training examples.&lt;/p>
&lt;figure>
&lt;img src="molecule_generation_results.svg" width="100%">
&lt;figcaption>&lt;b>Figure 5&lt;/b>: Results on molecule generation task in comparison to other state-of-the-art models. GraphCNF performs favourably while usign no manually encoded rules during generation.&lt;/figcaption>
&lt;/figure>
&lt;p>The most common failure case we observed was that the sampled graph was not connected, meaning that we actually generate two or more separate graphs. This can happen as in contrast to autoregressive models, it is much harder for parallel models to ensure that every node can be reached from any other node. When considering the biggest subgraph in those generation, we are able to push the validity percentage to 96% without enforcing any explicit rule of molecule graphs. This is a relatively large gap to the closest state-of-the-art autoregressive flow model at the time of writing, GraphAF, and shows the importance of the encoding in Normalizing Flows, and permutation invariance for graph generation in general.&lt;/p>
&lt;h2 id="conclusion">Conclusion&lt;/h2>
&lt;p>In this blog post, we reviewed the key ideas behind Categorical Normalizing Flows and GraphCNF. As Normalizing Flows are naturally defined for continuous data, we can first the map discrete, categorical data into continuous space on which a flow can be applied. While doing so, factorizing the decoder helps by pushing all modeling complexity into the flow. GraphCNF relies on this principle to model graphs with categorical attributes such as molecules. In a three-step approach, it remains efficient yet provides a permutation invariant likelihood estimate of any graph. Future work can attempt to overcome the failure case of subgraph sampling in parallel graph models like GraphCNF, and scale it up to large graphs with more than 100 nodes.&lt;/p>
&lt;p>To read up on all the details of Categorical Normalizing Flows and GraphCNF, please see our paper &lt;a href="../../publication/lippe-2021-categorical/">&lt;em>Categorical Normalizing Flows via Continuous Transformations&lt;/em>&lt;/a>.&lt;/p></description></item></channel></rss>